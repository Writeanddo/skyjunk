Shader "dashedLine_stencil"
{
    Properties
    {
        Vector1_AB1327B9("Break Size", Float) = 0.1
Vector1_C92DAC8E("Speed", Float) = 1
Vector1_89BA4AC1("Bands", Float) = 1
Vector1_DAB9439E("Fade", Float) = 0.1
[ToggleUI] Boolean_DAAF320C("useUnscaledTime", Float) = 0

// required for UI.Mask
_StencilComp ("Stencil Comparison", Float) = 8
_Stencil ("Stencil ID", Float) = 0
_StencilOp ("Stencil Operation", Float) = 0
_StencilWriteMask ("Stencil Write Mask", Float) = 255
_StencilReadMask ("Stencil Read Mask", Float) = 255
_ColorMask ("Color Mask", Float) = 15

    }
    SubShader
    {
        Tags
        {
            "RenderPipeline"="LightweightPipeline"
            "RenderType"="Transparent"
            "Queue"="Transparent+0"
        }
        Pass
        {
            Name "StandardUnlit"
            Tags{"LightMode" = "LightweightForward"}

            // Material options generated by graph

            Blend SrcAlpha OneMinusSrcAlpha, One OneMinusSrcAlpha

            Cull Off

            ZTest LEqual

            ZWrite Off

            Stencil
            {
                Ref [_Stencil]
                Comp [_StencilComp]
                Pass [_StencilOp] 
                ReadMask [_StencilReadMask]
                WriteMask [_StencilWriteMask]
            }
            ColorMask [_ColorMask]

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            // -------------------------------------
            // Lightweight Pipeline keywords
            #pragma shader_feature _SAMPLE_GI

            // -------------------------------------
            // Unity defined keywords
            #pragma multi_compile _ DIRLIGHTMAP_COMBINED
            #pragma multi_compile _ LIGHTMAP_ON
            #pragma multi_compile_fog

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing
            
            #pragma vertex vert
            #pragma fragment frag

            // Defines generated by graph

            // Includes
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl"

            CBUFFER_START(UnityPerMaterial)
            float Vector1_AB1327B9;
            float Vector1_C92DAC8E;
            float Vector1_89BA4AC1;
            float Vector1_DAB9439E;
            float Boolean_DAAF320C;
            float _Stencil;
            CBUFFER_END

            float _UnscaledTime;

            struct VertexDescriptionInputs
            {
                float3 ObjectSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                float4 VertexColor;
                half4 uv0;
            };


            void Unity_Subtract_float(float A, float B, out float Out)
            {
                Out = A - B;
            }

            void Unity_Add_float(float A, float B, out float Out)
            {
                Out = A + B;
            }

            void Unity_OneMinus_float(float In, out float Out)
            {
                Out = 1 - In;
            }

            void Unity_Multiply_float (float A, float B, out float Out)
            {
                Out = A * B;
            }

            void Unity_Branch_float(float Predicate, float True, float False, out float Out)
            {
                Out = lerp(False, True, Predicate);
            }

            void Unity_Sine_float(float In, out float Out)
            {
                Out = sin(In);
            }

            void Unity_Maximum_float(float A, float B, out float Out)
            {
                Out = max(A, B);
            }

            void Unity_Smoothstep_float(float Edge1, float Edge2, float In, out float Out)
            {
                Out = smoothstep(Edge1, Edge2, In);
            }

            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                description.Position = IN.ObjectSpacePosition;
                return description;
            }

            struct SurfaceDescription
            {
                float3 Color;
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float _Property_3723CFBE_Out_0 = Vector1_AB1327B9;
                float _Property_CE4605A8_Out_0 = Vector1_DAB9439E;
                float _Subtract_FF37CDA0_Out_2;
                Unity_Subtract_float(_Property_3723CFBE_Out_0, _Property_CE4605A8_Out_0, _Subtract_FF37CDA0_Out_2);
                float _Add_3DD9480B_Out_2;
                Unity_Add_float(_Property_3723CFBE_Out_0, _Property_CE4605A8_Out_0, _Add_3DD9480B_Out_2);
                float4 _UV_FDC11994_Out_0 = IN.uv0;
                float _Split_C339AE53_R_1 = _UV_FDC11994_Out_0[0];
                float _Split_C339AE53_G_2 = _UV_FDC11994_Out_0[1];
                float _Split_C339AE53_B_3 = _UV_FDC11994_Out_0[2];
                float _Split_C339AE53_A_4 = _UV_FDC11994_Out_0[3];
                float _OneMinus_323562F8_Out_1;
                Unity_OneMinus_float(_Split_C339AE53_G_2, _OneMinus_323562F8_Out_1);
                float _Multiply_DD0BF097_Out_2;
                Unity_Multiply_float(_OneMinus_323562F8_Out_1, _Split_C339AE53_G_2, _Multiply_DD0BF097_Out_2);

                float _Property_8336C43E_Out_0 = Vector1_89BA4AC1;
                float _Property_D3340426_Out_0 = Boolean_DAAF320C;
                float _Property_7731EC6C_Out_0 = _UnscaledTime;
                float _Branch_325C400D_Out_3;
                Unity_Branch_float(_Property_D3340426_Out_0, _Property_7731EC6C_Out_0, _Time.y, _Branch_325C400D_Out_3);
                float _Property_C77CEB97_Out_0 = Vector1_C92DAC8E;
                float _Multiply_C0F9BDFB_Out_2;
                Unity_Multiply_float(_Branch_325C400D_Out_3, _Property_C77CEB97_Out_0, _Multiply_C0F9BDFB_Out_2);

                float _Add_8E840958_Out_2;
                Unity_Add_float(_Split_C339AE53_R_1, _Multiply_C0F9BDFB_Out_2, _Add_8E840958_Out_2);
                float _Multiply_A4E694C1_Out_2;
                Unity_Multiply_float(_Add_8E840958_Out_2, 6.28, _Multiply_A4E694C1_Out_2);

                float _Multiply_C43C89EC_Out_2;
                Unity_Multiply_float(_Property_8336C43E_Out_0, _Multiply_A4E694C1_Out_2, _Multiply_C43C89EC_Out_2);

                float _Sine_D67883ED_Out_1;
                Unity_Sine_float(_Multiply_C43C89EC_Out_2, _Sine_D67883ED_Out_1);
                float _Maximum_729334EE_Out_2;
                Unity_Maximum_float(_Sine_D67883ED_Out_1, 0, _Maximum_729334EE_Out_2);
                float _Multiply_A6149FF8_Out_2;
                Unity_Multiply_float(_Multiply_DD0BF097_Out_2, _Maximum_729334EE_Out_2, _Multiply_A6149FF8_Out_2);

                float _Smoothstep_32D211B3_Out_3;
                Unity_Smoothstep_float(_Subtract_FF37CDA0_Out_2, _Add_3DD9480B_Out_2, _Multiply_A6149FF8_Out_2, _Smoothstep_32D211B3_Out_3);
                surface.Color = (IN.VertexColor.xyz);
                surface.Alpha = _Smoothstep_32D211B3_Out_3;
                surface.AlphaClipThreshold = 0.5;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 color : COLOR;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


            struct GraphVertexOutput
            {
                float4 position : POSITION;

                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                float4 VertexColor : COLOR;
                half4 uv0 : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
            };

            GraphVertexOutput vert (GraphVertexInput v)
            {
                GraphVertexOutput o = (GraphVertexOutput)0;
                UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

                // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 VertexColor = v.color;
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

                VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

                // Vertex description inputs defined by graph
                vdi.ObjectSpacePosition = ObjectSpacePosition;

                VertexDescription vd = PopulateVertexData(vdi);
                v.vertex.xyz = vd.Position;

                o.position = TransformObjectToHClip(v.vertex.xyz);
                // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.VertexColor = VertexColor;
                o.uv0 = uv0;
                o.uv1 = uv1;

                return o;
            }

            half4 frag (GraphVertexOutput IN ) : SV_Target
            {
                UNITY_SETUP_INSTANCE_ID(IN);
        		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float4 VertexColor = IN.VertexColor;
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;

                
                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;
                // Surface description inputs defined by graph
                surfaceInput.VertexColor = VertexColor;
                surfaceInput.uv0 = uv0;


                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);
                float3 Color = float3(0.5, 0.5, 0.5);
                float Alpha = 1;
                float AlphaClipThreshold = 0;
                // Surface description remap performed by graph
                Color = surf.Color;
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;

                
         #if _AlphaClip
                clip(Alpha - AlphaClipThreshold);
        #endif
                return half4(Color, Alpha);
            }
            ENDHLSL
        }
        Pass
        {
            Name "ShadowCaster"
            Tags{"LightMode" = "ShadowCaster"}

            ZWrite On ZTest LEqual

            // Material options generated by graph
            Cull Off

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing

            #pragma vertex ShadowPassVertex
            #pragma fragment ShadowPassFragment

            // Defines generated by graph

            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl"

            CBUFFER_START(UnityPerMaterial)
            float Vector1_AB1327B9;
            float Vector1_C92DAC8E;
            float Vector1_89BA4AC1;
            float Vector1_DAB9439E;
            float Boolean_DAAF320C;
            float _Stencil;
            CBUFFER_END

            float _UnscaledTime;

            struct VertexDescriptionInputs
            {
                float3 ObjectSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                half4 uv0;
            };


            void Unity_Subtract_float(float A, float B, out float Out)
            {
                Out = A - B;
            }

            void Unity_Add_float(float A, float B, out float Out)
            {
                Out = A + B;
            }

            void Unity_OneMinus_float(float In, out float Out)
            {
                Out = 1 - In;
            }

            void Unity_Multiply_float (float A, float B, out float Out)
            {
                Out = A * B;
            }

            void Unity_Branch_float(float Predicate, float True, float False, out float Out)
            {
                Out = lerp(False, True, Predicate);
            }

            void Unity_Sine_float(float In, out float Out)
            {
                Out = sin(In);
            }

            void Unity_Maximum_float(float A, float B, out float Out)
            {
                Out = max(A, B);
            }

            void Unity_Smoothstep_float(float Edge1, float Edge2, float In, out float Out)
            {
                Out = smoothstep(Edge1, Edge2, In);
            }

            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                description.Position = IN.ObjectSpacePosition;
                return description;
            }

            struct SurfaceDescription
            {
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float _Property_3723CFBE_Out_0 = Vector1_AB1327B9;
                float _Property_CE4605A8_Out_0 = Vector1_DAB9439E;
                float _Subtract_FF37CDA0_Out_2;
                Unity_Subtract_float(_Property_3723CFBE_Out_0, _Property_CE4605A8_Out_0, _Subtract_FF37CDA0_Out_2);
                float _Add_3DD9480B_Out_2;
                Unity_Add_float(_Property_3723CFBE_Out_0, _Property_CE4605A8_Out_0, _Add_3DD9480B_Out_2);
                float4 _UV_FDC11994_Out_0 = IN.uv0;
                float _Split_C339AE53_R_1 = _UV_FDC11994_Out_0[0];
                float _Split_C339AE53_G_2 = _UV_FDC11994_Out_0[1];
                float _Split_C339AE53_B_3 = _UV_FDC11994_Out_0[2];
                float _Split_C339AE53_A_4 = _UV_FDC11994_Out_0[3];
                float _OneMinus_323562F8_Out_1;
                Unity_OneMinus_float(_Split_C339AE53_G_2, _OneMinus_323562F8_Out_1);
                float _Multiply_DD0BF097_Out_2;
                Unity_Multiply_float(_OneMinus_323562F8_Out_1, _Split_C339AE53_G_2, _Multiply_DD0BF097_Out_2);

                float _Property_8336C43E_Out_0 = Vector1_89BA4AC1;
                float _Property_D3340426_Out_0 = Boolean_DAAF320C;
                float _Property_7731EC6C_Out_0 = _UnscaledTime;
                float _Branch_325C400D_Out_3;
                Unity_Branch_float(_Property_D3340426_Out_0, _Property_7731EC6C_Out_0, _Time.y, _Branch_325C400D_Out_3);
                float _Property_C77CEB97_Out_0 = Vector1_C92DAC8E;
                float _Multiply_C0F9BDFB_Out_2;
                Unity_Multiply_float(_Branch_325C400D_Out_3, _Property_C77CEB97_Out_0, _Multiply_C0F9BDFB_Out_2);

                float _Add_8E840958_Out_2;
                Unity_Add_float(_Split_C339AE53_R_1, _Multiply_C0F9BDFB_Out_2, _Add_8E840958_Out_2);
                float _Multiply_A4E694C1_Out_2;
                Unity_Multiply_float(_Add_8E840958_Out_2, 6.28, _Multiply_A4E694C1_Out_2);

                float _Multiply_C43C89EC_Out_2;
                Unity_Multiply_float(_Property_8336C43E_Out_0, _Multiply_A4E694C1_Out_2, _Multiply_C43C89EC_Out_2);

                float _Sine_D67883ED_Out_1;
                Unity_Sine_float(_Multiply_C43C89EC_Out_2, _Sine_D67883ED_Out_1);
                float _Maximum_729334EE_Out_2;
                Unity_Maximum_float(_Sine_D67883ED_Out_1, 0, _Maximum_729334EE_Out_2);
                float _Multiply_A6149FF8_Out_2;
                Unity_Multiply_float(_Multiply_DD0BF097_Out_2, _Maximum_729334EE_Out_2, _Multiply_A6149FF8_Out_2);

                float _Smoothstep_32D211B3_Out_3;
                Unity_Smoothstep_float(_Subtract_FF37CDA0_Out_2, _Add_3DD9480B_Out_2, _Multiply_A6149FF8_Out_2, _Smoothstep_32D211B3_Out_3);
                surface.Alpha = _Smoothstep_32D211B3_Out_3;
                surface.AlphaClipThreshold = 0.5;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


            struct VertexOutput
            {
                float2 uv           : TEXCOORD0;
                float4 clipPos      : SV_POSITION;
                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                half4 uv0 : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
            };

            float3 _LightDirection;

            VertexOutput ShadowPassVertex(GraphVertexInput v)
            {
                VertexOutput o;
                UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

                // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

                VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

                // Vertex description inputs defined by graph
                vdi.ObjectSpacePosition = ObjectSpacePosition;

                VertexDescription vd = PopulateVertexData(vdi);
                v.vertex.xyz = vd.Position;

                // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.uv0 = uv0;
                o.uv1 = uv1;

                
                float3 positionWS = TransformObjectToWorld(v.vertex.xyz);
                float3 normalWS = TransformObjectToWorldNormal(v.normal);

                float4 clipPos = TransformWorldToHClip(ApplyShadowBias(positionWS, normalWS, _LightDirection));

            #if UNITY_REVERSED_Z
                clipPos.z = min(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
            #else
                clipPos.z = max(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
            #endif
                o.clipPos = clipPos;

                return o;
            }

            half4 ShadowPassFragment(VertexOutput IN ) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(IN);
        		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

        		// Surface description inputs defined by graph
                surfaceInput.uv0 = uv0;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

        		float Alpha = 1;
        		float AlphaClipThreshold = 0;

        		// Surface description remap performed by graph
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;

         #if _AlphaClip
        		clip(Alpha - AlphaClipThreshold);
        #endif
                return 0;
            }

            ENDHLSL
        }

        Pass
        {
            Name "DepthOnly"
            Tags{"LightMode" = "DepthOnly"}

            ZWrite On
            ColorMask 0

            // Material options generated by graph
            Cull Off

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing

            #pragma vertex vert
            #pragma fragment frag

            // Defines generated by graph

            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl"

            CBUFFER_START(UnityPerMaterial)
            float Vector1_AB1327B9;
            float Vector1_C92DAC8E;
            float Vector1_89BA4AC1;
            float Vector1_DAB9439E;
            float Boolean_DAAF320C;
            float _Stencil;
            CBUFFER_END

            float _UnscaledTime;

            struct VertexDescriptionInputs
            {
                float3 ObjectSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                half4 uv0;
            };


            void Unity_Subtract_float(float A, float B, out float Out)
            {
                Out = A - B;
            }

            void Unity_Add_float(float A, float B, out float Out)
            {
                Out = A + B;
            }

            void Unity_OneMinus_float(float In, out float Out)
            {
                Out = 1 - In;
            }

            void Unity_Multiply_float (float A, float B, out float Out)
            {
                Out = A * B;
            }

            void Unity_Branch_float(float Predicate, float True, float False, out float Out)
            {
                Out = lerp(False, True, Predicate);
            }

            void Unity_Sine_float(float In, out float Out)
            {
                Out = sin(In);
            }

            void Unity_Maximum_float(float A, float B, out float Out)
            {
                Out = max(A, B);
            }

            void Unity_Smoothstep_float(float Edge1, float Edge2, float In, out float Out)
            {
                Out = smoothstep(Edge1, Edge2, In);
            }

            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                description.Position = IN.ObjectSpacePosition;
                return description;
            }

            struct SurfaceDescription
            {
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float _Property_3723CFBE_Out_0 = Vector1_AB1327B9;
                float _Property_CE4605A8_Out_0 = Vector1_DAB9439E;
                float _Subtract_FF37CDA0_Out_2;
                Unity_Subtract_float(_Property_3723CFBE_Out_0, _Property_CE4605A8_Out_0, _Subtract_FF37CDA0_Out_2);
                float _Add_3DD9480B_Out_2;
                Unity_Add_float(_Property_3723CFBE_Out_0, _Property_CE4605A8_Out_0, _Add_3DD9480B_Out_2);
                float4 _UV_FDC11994_Out_0 = IN.uv0;
                float _Split_C339AE53_R_1 = _UV_FDC11994_Out_0[0];
                float _Split_C339AE53_G_2 = _UV_FDC11994_Out_0[1];
                float _Split_C339AE53_B_3 = _UV_FDC11994_Out_0[2];
                float _Split_C339AE53_A_4 = _UV_FDC11994_Out_0[3];
                float _OneMinus_323562F8_Out_1;
                Unity_OneMinus_float(_Split_C339AE53_G_2, _OneMinus_323562F8_Out_1);
                float _Multiply_DD0BF097_Out_2;
                Unity_Multiply_float(_OneMinus_323562F8_Out_1, _Split_C339AE53_G_2, _Multiply_DD0BF097_Out_2);

                float _Property_8336C43E_Out_0 = Vector1_89BA4AC1;
                float _Property_D3340426_Out_0 = Boolean_DAAF320C;
                float _Property_7731EC6C_Out_0 = _UnscaledTime;
                float _Branch_325C400D_Out_3;
                Unity_Branch_float(_Property_D3340426_Out_0, _Property_7731EC6C_Out_0, _Time.y, _Branch_325C400D_Out_3);
                float _Property_C77CEB97_Out_0 = Vector1_C92DAC8E;
                float _Multiply_C0F9BDFB_Out_2;
                Unity_Multiply_float(_Branch_325C400D_Out_3, _Property_C77CEB97_Out_0, _Multiply_C0F9BDFB_Out_2);

                float _Add_8E840958_Out_2;
                Unity_Add_float(_Split_C339AE53_R_1, _Multiply_C0F9BDFB_Out_2, _Add_8E840958_Out_2);
                float _Multiply_A4E694C1_Out_2;
                Unity_Multiply_float(_Add_8E840958_Out_2, 6.28, _Multiply_A4E694C1_Out_2);

                float _Multiply_C43C89EC_Out_2;
                Unity_Multiply_float(_Property_8336C43E_Out_0, _Multiply_A4E694C1_Out_2, _Multiply_C43C89EC_Out_2);

                float _Sine_D67883ED_Out_1;
                Unity_Sine_float(_Multiply_C43C89EC_Out_2, _Sine_D67883ED_Out_1);
                float _Maximum_729334EE_Out_2;
                Unity_Maximum_float(_Sine_D67883ED_Out_1, 0, _Maximum_729334EE_Out_2);
                float _Multiply_A6149FF8_Out_2;
                Unity_Multiply_float(_Multiply_DD0BF097_Out_2, _Maximum_729334EE_Out_2, _Multiply_A6149FF8_Out_2);

                float _Smoothstep_32D211B3_Out_3;
                Unity_Smoothstep_float(_Subtract_FF37CDA0_Out_2, _Add_3DD9480B_Out_2, _Multiply_A6149FF8_Out_2, _Smoothstep_32D211B3_Out_3);
                surface.Alpha = _Smoothstep_32D211B3_Out_3;
                surface.AlphaClipThreshold = 0.5;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


            struct VertexOutput
            {
                float2 uv           : TEXCOORD0;
                float4 clipPos      : SV_POSITION;
                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                half4 uv0 : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
            };

            VertexOutput vert(GraphVertexInput v)
            {
                VertexOutput o = (VertexOutput)0;
                UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

                // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

                VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

                // Vertex description inputs defined by graph
                vdi.ObjectSpacePosition = ObjectSpacePosition;

                VertexDescription vd = PopulateVertexData(vdi);
                v.vertex.xyz = vd.Position;

                // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.uv0 = uv0;
                o.uv1 = uv1;

                o.clipPos = TransformObjectToHClip(v.vertex.xyz);
                return o;
            }

            half4 frag(VertexOutput IN ) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(IN);
        		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

        		// Surface description inputs defined by graph
                surfaceInput.uv0 = uv0;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

        		float Alpha = 1;
        		float AlphaClipThreshold = 0;

        		// Surface description remap performed by graph
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;

         #if _AlphaClip
        		clip(Alpha - AlphaClipThreshold);
        #endif
                return 0;
            }
            ENDHLSL
        }
    }
    FallBack "Hidden/InternalErrorShader"
}
